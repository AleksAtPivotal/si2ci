// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"

	"github.com/concourse/atc/db"
)

type FakeContainerRepository struct {
	FindOrphanedContainersStub        func() ([]db.CreatingContainer, []db.CreatedContainer, []db.DestroyingContainer, error)
	findOrphanedContainersMutex       sync.RWMutex
	findOrphanedContainersArgsForCall []struct{}
	findOrphanedContainersReturns     struct {
		result1 []db.CreatingContainer
		result2 []db.CreatedContainer
		result3 []db.DestroyingContainer
		result4 error
	}
	findOrphanedContainersReturnsOnCall map[int]struct {
		result1 []db.CreatingContainer
		result2 []db.CreatedContainer
		result3 []db.DestroyingContainer
		result4 error
	}
	DestroyFailedContainersStub        func() (int, error)
	destroyFailedContainersMutex       sync.RWMutex
	destroyFailedContainersArgsForCall []struct{}
	destroyFailedContainersReturns     struct {
		result1 int
		result2 error
	}
	destroyFailedContainersReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	FindDestroyingContainersStub        func(workerName string) ([]string, error)
	findDestroyingContainersMutex       sync.RWMutex
	findDestroyingContainersArgsForCall []struct {
		workerName string
	}
	findDestroyingContainersReturns struct {
		result1 []string
		result2 error
	}
	findDestroyingContainersReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	RemoveDestroyingContainersStub        func(workerName string, currentHandles []string) (int, error)
	removeDestroyingContainersMutex       sync.RWMutex
	removeDestroyingContainersArgsForCall []struct {
		workerName     string
		currentHandles []string
	}
	removeDestroyingContainersReturns struct {
		result1 int
		result2 error
	}
	removeDestroyingContainersReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeContainerRepository) FindOrphanedContainers() ([]db.CreatingContainer, []db.CreatedContainer, []db.DestroyingContainer, error) {
	fake.findOrphanedContainersMutex.Lock()
	ret, specificReturn := fake.findOrphanedContainersReturnsOnCall[len(fake.findOrphanedContainersArgsForCall)]
	fake.findOrphanedContainersArgsForCall = append(fake.findOrphanedContainersArgsForCall, struct{}{})
	fake.recordInvocation("FindOrphanedContainers", []interface{}{})
	fake.findOrphanedContainersMutex.Unlock()
	if fake.FindOrphanedContainersStub != nil {
		return fake.FindOrphanedContainersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.findOrphanedContainersReturns.result1, fake.findOrphanedContainersReturns.result2, fake.findOrphanedContainersReturns.result3, fake.findOrphanedContainersReturns.result4
}

func (fake *FakeContainerRepository) FindOrphanedContainersCallCount() int {
	fake.findOrphanedContainersMutex.RLock()
	defer fake.findOrphanedContainersMutex.RUnlock()
	return len(fake.findOrphanedContainersArgsForCall)
}

func (fake *FakeContainerRepository) FindOrphanedContainersReturns(result1 []db.CreatingContainer, result2 []db.CreatedContainer, result3 []db.DestroyingContainer, result4 error) {
	fake.FindOrphanedContainersStub = nil
	fake.findOrphanedContainersReturns = struct {
		result1 []db.CreatingContainer
		result2 []db.CreatedContainer
		result3 []db.DestroyingContainer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeContainerRepository) FindOrphanedContainersReturnsOnCall(i int, result1 []db.CreatingContainer, result2 []db.CreatedContainer, result3 []db.DestroyingContainer, result4 error) {
	fake.FindOrphanedContainersStub = nil
	if fake.findOrphanedContainersReturnsOnCall == nil {
		fake.findOrphanedContainersReturnsOnCall = make(map[int]struct {
			result1 []db.CreatingContainer
			result2 []db.CreatedContainer
			result3 []db.DestroyingContainer
			result4 error
		})
	}
	fake.findOrphanedContainersReturnsOnCall[i] = struct {
		result1 []db.CreatingContainer
		result2 []db.CreatedContainer
		result3 []db.DestroyingContainer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeContainerRepository) DestroyFailedContainers() (int, error) {
	fake.destroyFailedContainersMutex.Lock()
	ret, specificReturn := fake.destroyFailedContainersReturnsOnCall[len(fake.destroyFailedContainersArgsForCall)]
	fake.destroyFailedContainersArgsForCall = append(fake.destroyFailedContainersArgsForCall, struct{}{})
	fake.recordInvocation("DestroyFailedContainers", []interface{}{})
	fake.destroyFailedContainersMutex.Unlock()
	if fake.DestroyFailedContainersStub != nil {
		return fake.DestroyFailedContainersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.destroyFailedContainersReturns.result1, fake.destroyFailedContainersReturns.result2
}

func (fake *FakeContainerRepository) DestroyFailedContainersCallCount() int {
	fake.destroyFailedContainersMutex.RLock()
	defer fake.destroyFailedContainersMutex.RUnlock()
	return len(fake.destroyFailedContainersArgsForCall)
}

func (fake *FakeContainerRepository) DestroyFailedContainersReturns(result1 int, result2 error) {
	fake.DestroyFailedContainersStub = nil
	fake.destroyFailedContainersReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) DestroyFailedContainersReturnsOnCall(i int, result1 int, result2 error) {
	fake.DestroyFailedContainersStub = nil
	if fake.destroyFailedContainersReturnsOnCall == nil {
		fake.destroyFailedContainersReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.destroyFailedContainersReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) FindDestroyingContainers(workerName string) ([]string, error) {
	fake.findDestroyingContainersMutex.Lock()
	ret, specificReturn := fake.findDestroyingContainersReturnsOnCall[len(fake.findDestroyingContainersArgsForCall)]
	fake.findDestroyingContainersArgsForCall = append(fake.findDestroyingContainersArgsForCall, struct {
		workerName string
	}{workerName})
	fake.recordInvocation("FindDestroyingContainers", []interface{}{workerName})
	fake.findDestroyingContainersMutex.Unlock()
	if fake.FindDestroyingContainersStub != nil {
		return fake.FindDestroyingContainersStub(workerName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findDestroyingContainersReturns.result1, fake.findDestroyingContainersReturns.result2
}

func (fake *FakeContainerRepository) FindDestroyingContainersCallCount() int {
	fake.findDestroyingContainersMutex.RLock()
	defer fake.findDestroyingContainersMutex.RUnlock()
	return len(fake.findDestroyingContainersArgsForCall)
}

func (fake *FakeContainerRepository) FindDestroyingContainersArgsForCall(i int) string {
	fake.findDestroyingContainersMutex.RLock()
	defer fake.findDestroyingContainersMutex.RUnlock()
	return fake.findDestroyingContainersArgsForCall[i].workerName
}

func (fake *FakeContainerRepository) FindDestroyingContainersReturns(result1 []string, result2 error) {
	fake.FindDestroyingContainersStub = nil
	fake.findDestroyingContainersReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) FindDestroyingContainersReturnsOnCall(i int, result1 []string, result2 error) {
	fake.FindDestroyingContainersStub = nil
	if fake.findDestroyingContainersReturnsOnCall == nil {
		fake.findDestroyingContainersReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.findDestroyingContainersReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) RemoveDestroyingContainers(workerName string, currentHandles []string) (int, error) {
	var currentHandlesCopy []string
	if currentHandles != nil {
		currentHandlesCopy = make([]string, len(currentHandles))
		copy(currentHandlesCopy, currentHandles)
	}
	fake.removeDestroyingContainersMutex.Lock()
	ret, specificReturn := fake.removeDestroyingContainersReturnsOnCall[len(fake.removeDestroyingContainersArgsForCall)]
	fake.removeDestroyingContainersArgsForCall = append(fake.removeDestroyingContainersArgsForCall, struct {
		workerName     string
		currentHandles []string
	}{workerName, currentHandlesCopy})
	fake.recordInvocation("RemoveDestroyingContainers", []interface{}{workerName, currentHandlesCopy})
	fake.removeDestroyingContainersMutex.Unlock()
	if fake.RemoveDestroyingContainersStub != nil {
		return fake.RemoveDestroyingContainersStub(workerName, currentHandles)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.removeDestroyingContainersReturns.result1, fake.removeDestroyingContainersReturns.result2
}

func (fake *FakeContainerRepository) RemoveDestroyingContainersCallCount() int {
	fake.removeDestroyingContainersMutex.RLock()
	defer fake.removeDestroyingContainersMutex.RUnlock()
	return len(fake.removeDestroyingContainersArgsForCall)
}

func (fake *FakeContainerRepository) RemoveDestroyingContainersArgsForCall(i int) (string, []string) {
	fake.removeDestroyingContainersMutex.RLock()
	defer fake.removeDestroyingContainersMutex.RUnlock()
	return fake.removeDestroyingContainersArgsForCall[i].workerName, fake.removeDestroyingContainersArgsForCall[i].currentHandles
}

func (fake *FakeContainerRepository) RemoveDestroyingContainersReturns(result1 int, result2 error) {
	fake.RemoveDestroyingContainersStub = nil
	fake.removeDestroyingContainersReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) RemoveDestroyingContainersReturnsOnCall(i int, result1 int, result2 error) {
	fake.RemoveDestroyingContainersStub = nil
	if fake.removeDestroyingContainersReturnsOnCall == nil {
		fake.removeDestroyingContainersReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.removeDestroyingContainersReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.findOrphanedContainersMutex.RLock()
	defer fake.findOrphanedContainersMutex.RUnlock()
	fake.destroyFailedContainersMutex.RLock()
	defer fake.destroyFailedContainersMutex.RUnlock()
	fake.findDestroyingContainersMutex.RLock()
	defer fake.findDestroyingContainersMutex.RUnlock()
	fake.removeDestroyingContainersMutex.RLock()
	defer fake.removeDestroyingContainersMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeContainerRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.ContainerRepository = new(FakeContainerRepository)
